#################################################################
# This contains data manipulation functions for working with    #
# aneuploidy call data generated by Natera. These functions are #
# specific to the formatting of the CSV data file.              #
#################################################################


# Function: filterData(data)
# Performs QC filtering to remove samples with excessive low confidence calls
# or whole chromosome nullisomy. Columns that contain aneuploidy calls are 
# hard-coded (7:29, in this case)

filterData <- function(data) {
	data_calls <- data[,7:29]; nrow(data_calls)
	data_calls <- data_calls[(apply(data_calls, 1, function(x) sum(is.na(x))) < 5),] # remove samples with 5+ no-calls
	data_calls <- data_calls[(apply(data_calls, 1, function(x) sum(x[!is.na(x)] == "H000")) != 23),] # remove whole genome nullisomy
	data_filtered <- data[row.names(data_calls),] #recover the original data frame, with all chrom. nullisomy and any chrom. no-calls filtered out
}

# Function: selectSampleType(data, sampleType)
# Subsets the dataset based on sample type. 

selectSampleType <- function(data, sampleType) {
	sampleType <- deparse(substitute(sampleType))
	data_subset <- data[data$sample_type == toString(sampleType),]
	return(data_subset)
}

# Function: callPloidy
# Adds a new boolean field called 'ploidy' that indicates whole-chromosome aneuploidy with 'FALSE'
callPloidy <- function(data) {
	aneuploid_frame <- data.frame(matrix(ncol = 23, nrow = nrow(data)))
	for (i in 7:29) {
		new <- (data[,i] != "H110" & data[,i] != "H101" & data[,i+69] != 1)
		aneuploid_frame[,i-6] <- new
	}
	aneuploid_indicator <- (apply(aneuploid_frame[,1:23], 1, function(x) sum(x[!is.na(x)]==TRUE)) > 0) # if any chromosome is aneuploid, call sample aneuploid
	data$ploidy<-TRUE
	data$ploidy[aneuploid_indicator]<-FALSE
	return(data)
}

# Function: callEuploidy
# Adds a new boolean field called 'euploidy' that indicates euploidy with 'TRUE'. This is not the 
# inverse of the aneuploid embryos from 'callPloidy', as any segmental duplications or deletions 
# are considered aneuploidies in this case.

callEuploidy <- function(data) {
	aneuploid_frame <- data.frame(matrix(ncol = 23, nrow = nrow(data)))
	for (i in 7:29) {
		new <- (data[,i] != "H110" & data[,i] != "H101")
		aneuploid_frame[,i-6] <- new
	}
	aneuploid_indicator <- (apply(aneuploid_frame[,1:23], 1, function(x) sum(x[!is.na(x)]==TRUE)) > 0) # if any chromosome is aneuploid, call sample aneuploid
	data$euploidy<-TRUE
	data$euploidy[aneuploid_indicator]<-FALSE
	return(data)
}

# Function: euploidyByAge
# Returns data frame that summarizes rate of aneuploidy versus maternal age

aneuploidyByAge <- function(data, label) {
	results <- data.frame(matrix(ncol = 5))
	minAge <- min(data$maternal_age[!is.na(data$maternal_age)])
	maxAge <- max(data$maternal_age[!is.na(data$maternal_age)])
	
	for (k in round(minAge):round(maxAge)) {	
		age_subset <- data[round(data$maternal_age) == k & !is.na(round(data$maternal_age)),]
		aneuploidy_prop <- (sum(age_subset$ploidy == FALSE)) / nrow(age_subset)
		se <- sqrt((aneuploidy_prop * (1 - aneuploidy_prop)) / nrow(age_subset)) # calculate standard error of proportion
		aneuploidy <- c(aneuploidy_prop, se, k, label, nrow(age_subset))
		results<-rbind(results, aneuploidy)
	}
	results$X1 <- as.numeric(results$X1)
	results$X2 <- as.numeric(results$X2)
	results$X3 <- as.numeric(results$X3)
	results$X5 <- as.numeric(results$X5)
	return(results[-1,])
}

# Function: euploidyByAge
# Returns data frame that summarizes rate of euploidy versus maternal age

euploidyByAge <- function(data, label) {
	results <- data.frame(matrix(ncol = 5))
	minAge <- min(data$maternal_age[!is.na(data$maternal_age)])
	maxAge <- max(data$maternal_age[!is.na(data$maternal_age)])
	
	for (k in round(minAge):round(maxAge)) {	
		age_subset <- data[round(data$maternal_age) == k & !is.na(round(data$maternal_age)),]
		euploidy_prop <- (sum(age_subset$euploidy == TRUE)) / nrow(age_subset)
		se <- sqrt((euploidy_prop * (1 - euploidy_prop)) / nrow(age_subset)) # calculate standard error of proportion
		euploidy <- c(euploidy_prop, se, k, label, nrow(age_subset))
		results<-rbind(results, euploidy)
	}
	results$X1 <- as.numeric(results$X1)
	results$X2 <- as.numeric(results$X2)
	results$X3 <- as.numeric(results$X3)
	results$X5 <- as.numeric(results$X5)
	return(results[-1,])
}

# Function: aneuploidyByCase
# counts aneuploid and euploid embryos by case and returns as data frame

aneuploidyByCase <- function(data) {
	aneuploid_counts <- data.frame()
	for (i in unique(data$case)) {
		subset <- data_filtered[data$case == i,]
		euploid <- sum(subset$ploidy == TRUE)
		aneuploid <- sum(subset$ploidy == FALSE)
		aneuploid_counts <- rbind(aneuploid_counts, cbind(i, euploid, aneuploid))
	}
	return(aneuploid_counts)
}
